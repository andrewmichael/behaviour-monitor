name: Release

# Workflow: Test â†’ Version Bump â†’ Create Release
# 1. Run tests first (required to pass)
# 2. If tests pass, analyze commits and bump version based on conventional commits
# 3. If version was bumped, create GitHub release with changelog and zip

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Force bump type (leave empty for auto-detect)"
        required: false
        type: choice
        options:
          - ""
          - patch
          - minor
          - major

permissions:
  contents: write

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    # Don't run on version bump commits (prevents infinite loop)
    if: "!startsWith(github.event.head_commit.message, 'chore(release):')"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
          pip install -r requirements-test.txt

      - name: Run tests
        id: test
        run: |
          python -m pytest tests/ -v --tb=short 2>&1 | tee test_output.txt
          echo "exit_code=${PIPESTATUS[0]}" >> $GITHUB_OUTPUT

      - name: Test Summary
        if: always()
        run: |
          # Extract test results from pytest output
          SUMMARY=$(grep -E "^=.*passed" test_output.txt || echo "")

          if [ "${{ steps.test.outputs.exit_code }}" == "0" ]; then
            echo "### âœ… All tests passed!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ -n "$SUMMARY" ]; then
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Proceeding with version bump and release..." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Tests failed!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ -n "$SUMMARY" ]; then
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ Version bump and release will not proceed." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  version-bump:
    name: Version Bump
    runs-on: ubuntu-latest
    needs: test
    # Don't run on version bump commits (prevents infinite loop)
    if: "!startsWith(github.event.head_commit.message, 'chore(release):')"
    outputs:
      bumped: ${{ steps.bump.outputs.bump_type != 'none' }}
      new_version: ${{ steps.new_version.outputs.new_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version
        id: current
        run: |
          VERSION=$(jq -r '.version' custom_components/behaviour_monitor/manifest.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Determine version bump
        id: bump
        run: |
          # Check for manual override first
          MANUAL_BUMP="${{ github.event.inputs.bump_type }}"
          if [ -n "$MANUAL_BUMP" ]; then
            echo "Manual bump type specified: $MANUAL_BUMP"
            echo "bump_type=$MANUAL_BUMP" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            # No tags yet, check only the latest commit
            COMMITS=$(git log -1 --pretty=format:"%s" --no-merges)
            echo "No previous tags found, checking latest commit only"
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          fi

          echo "Commits to analyze:"
          echo "$COMMITS"
          echo ""

          # Determine bump type based on conventional commits
          BUMP_TYPE="none"

          # Check for breaking changes (major bump)
          if echo "$COMMITS" | grep -qiE "^.*!:|BREAKING CHANGE:"; then
            BUMP_TYPE="major"
          # Check for features (minor bump)
          elif echo "$COMMITS" | grep -qiE "^feat(\(.*\))?:"; then
            BUMP_TYPE="minor"
          # Check for fixes or other changes (patch bump)
          elif echo "$COMMITS" | grep -qiE "^(fix|perf|refactor|style|docs|build|ci|chore|test)(\(.*\))?:"; then
            BUMP_TYPE="patch"
          fi

          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "Detected bump type: $BUMP_TYPE"

      - name: Calculate new version
        id: new_version
        if: steps.bump.outputs.bump_type != 'none'
        run: |
          CURRENT="${{ steps.current.outputs.version }}"
          BUMP_TYPE="${{ steps.bump.outputs.bump_type }}"

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Update version in files
        if: steps.bump.outputs.bump_type != 'none'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"

          # Update manifest.json
          jq --arg v "$NEW_VERSION" '.version = $v' custom_components/behaviour_monitor/manifest.json > tmp.json
          mv tmp.json custom_components/behaviour_monitor/manifest.json

          # Update sensor.py sw_version
          sed -i "s/sw_version=\"[0-9]*\.[0-9]*\.[0-9]*\"/sw_version=\"$NEW_VERSION\"/" custom_components/behaviour_monitor/sensor.py

          echo "Updated files to version $NEW_VERSION"

      - name: Update CHANGELOG.md
        if: steps.bump.outputs.bump_type != 'none'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          TODAY=$(date +%Y-%m-%d)

          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log -1 --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          fi

          # Initialize changelog sections
          ADDED=""
          CHANGED=""
          FIXED=""
          REMOVED=""
          SECURITY=""

          # Parse commits and categorize
          while IFS= read -r commit; do
            # Skip empty lines and release commits
            [ -z "$commit" ] && continue
            echo "$commit" | grep -qE "^chore\(release\):" && continue

            # Extract the message after the prefix
            MSG=$(echo "$commit" | sed -E 's/^[a-z]+(\([^)]*\))?!?:\s*//')

            # Categorize by conventional commit type
            if echo "$commit" | grep -qiE "^feat(\(.*\))?!?:"; then
              ADDED="${ADDED}- ${MSG}\n"
            elif echo "$commit" | grep -qiE "^fix(\(.*\))?:"; then
              FIXED="${FIXED}- ${MSG}\n"
            elif echo "$commit" | grep -qiE "^(refactor|perf|style)(\(.*\))?:"; then
              CHANGED="${CHANGED}- ${MSG}\n"
            elif echo "$commit" | grep -qiE "^docs(\(.*\))?:"; then
              CHANGED="${CHANGED}- Documentation: ${MSG}\n"
            elif echo "$commit" | grep -qiE "^security(\(.*\))?:"; then
              SECURITY="${SECURITY}- ${MSG}\n"
            elif echo "$commit" | grep -qiE "BREAKING CHANGE:|^.*!:"; then
              CHANGED="${CHANGED}- **BREAKING**: ${MSG}\n"
            fi
          done <<< "$COMMITS"

          # Build the new changelog entry
          ENTRY="## [${NEW_VERSION}] - ${TODAY}\n"

          [ -n "$ADDED" ] && ENTRY="${ENTRY}\n### Added\n${ADDED}"
          [ -n "$CHANGED" ] && ENTRY="${ENTRY}\n### Changed\n${CHANGED}"
          [ -n "$FIXED" ] && ENTRY="${ENTRY}\n### Fixed\n${FIXED}"
          [ -n "$REMOVED" ] && ENTRY="${ENTRY}\n### Removed\n${REMOVED}"
          [ -n "$SECURITY" ] && ENTRY="${ENTRY}\n### Security\n${SECURITY}"

          # If no categorized changes, add a generic entry
          if [ -z "$ADDED" ] && [ -z "$CHANGED" ] && [ -z "$FIXED" ] && [ -z "$REMOVED" ] && [ -z "$SECURITY" ]; then
            ENTRY="${ENTRY}\n### Changed\n- Version bump\n"
          fi

          # Insert new entry after [Unreleased] section
          awk -v entry="$ENTRY" '
            /^## \[Unreleased\]/ {
              print
              getline
              print
              printf "%s\n", entry
              next
            }
            { print }
          ' CHANGELOG.md > CHANGELOG.tmp && mv CHANGELOG.tmp CHANGELOG.md

          echo "Updated CHANGELOG.md with version $NEW_VERSION"

      - name: Commit and tag
        if: steps.bump.outputs.bump_type != 'none'
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
          BUMP_TYPE="${{ steps.bump.outputs.bump_type }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add custom_components/behaviour_monitor/manifest.json
          git add custom_components/behaviour_monitor/sensor.py
          git add CHANGELOG.md

          git commit -m "chore(release): v${NEW_VERSION}"
          git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION} (${BUMP_TYPE} bump)"

          git push origin HEAD
          git push origin "v${NEW_VERSION}"

      - name: Summary
        run: |
          if [ "${{ steps.bump.outputs.bump_type }}" == "none" ]; then
            echo "### â„¹ï¸ No version bump needed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âœ… Tests passed, but no conventional commit prefixes found in recent commits." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸŽ‰ Version bumped!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Previous:** ${{ steps.current.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **New:** ${{ steps.new_version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Bump type:** ${{ steps.bump.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“¦ GitHub release will be created next..." >> $GITHUB_STEP_SUMMARY
          fi

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: version-bump
    if: needs.version-bump.outputs.bumped == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: v${{ needs.version-bump.outputs.new_version }}

      - name: Create zip for HACS
        run: |
          # Zip the contents directly (not the directory itself)
          # This ensures HACS extracts files directly into custom_components/behaviour_monitor/
          cd custom_components/behaviour_monitor
          zip -r ../../behaviour_monitor.zip .

      - name: Generate release body
        run: |
          VERSION=${{ needs.version-bump.outputs.new_version }}

          # Extract the changelog section for this version
          CHANGELOG=$(awk "/^## \[${VERSION}\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md)

          # Build release body
          cat > release_body.md << 'ENDOFHEADER'
          ## What's Changed

          ENDOFHEADER

          if [ -n "$CHANGELOG" ]; then
            echo "$CHANGELOG" >> release_body.md
          else
            echo "See [CHANGELOG.md](CHANGELOG.md) for details." >> release_body.md
          fi

          cat >> release_body.md << 'ENDOFBODY'

          ## Installation

          ### HACS (Recommended)
          1. Open HACS in Home Assistant
          2. Go to Integrations
          3. Add this repository as a custom repository
          4. Search for "Behaviour Monitor" and install

          ### Manual
          1. Download `behaviour_monitor.zip` from this release
          2. Extract to `custom_components/behaviour_monitor/` in your HA config directory
          3. Restart Home Assistant

          ### ML Features (Optional)
          To enable ML-based anomaly detection, SSH into your HA OS and run:
          ```bash
          docker exec -it homeassistant pip install river
          ```
          ENDOFBODY

          echo "Generated release body:"
          cat release_body.md

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.version-bump.outputs.new_version }}
          files: behaviour_monitor.zip
          body_path: release_body.md
